% IF YOU CAN SEE THIS GO CONTRIBUTE >:(

\documentclass[letterpaper, 8pt]{extarticle}
\usepackage{amssymb,amsmath,amsthm,amsfonts}
\usepackage{multicol,multirow}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue]{hyperref}

\usepackage{booktabs}
\usepackage{ulem}
\usepackage{enumitem}
\usepackage{tabulary}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{derivative}
\usepackage{svg}
\usepackage{listings}
\usepackage{setspace}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier}

% minimal line spacing
\setstretch{0.1}

% set borders (experimentally determined to minimize cutoff and maximize space on school printers)
\geometry{top=.25in,left=.25in,right=.25in,bottom=.35in}

% make figures work better in multicol
\newenvironment{Figure}
{\par\medskip\noindent\minipage}
{\endminipage\par\medskip}

\pagestyle{empty} % clear page

% rewrite section commands to be smaller
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\tiny\bfseries}}
\makeatother
\setcounter{secnumdepth}{0} % disable section numbering

% disable indenting
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

% Custom siunitx defs
\DeclareSIUnit\noop{\relax}
\NewDocumentCommand\prefixvalue{m}{%
\qty[prefix-mode=extract-exponent,print-unity-mantissa=false]{1}{#1\noop}
}

% Shorthand definitions
\newcommand{\To}{\Rightarrow}
% holy fck thanks for this
\newcommand{\ttt}{\texttt}

% condense itemize & enumerate
\let\olditemize=\itemize \let\endolditemize=\enditemize \renewenvironment{itemize}{\olditemize \itemsep0em}{\endolditemize}
\let\oldenumerate=\enumerate \let\endoldenumerate=\endenumerate \renewenvironment{enumerate}{\oldenumerate \itemsep0em}{\endoldenumerate}
\setlist[itemize]{noitemsep, topsep=0pt, leftmargin=*}
\setlist[enumerate]{noitemsep, topsep=0pt, leftmargin=*}

\title{3SH3}

\begin{document}
\raggedright
\tiny

% make listings look nicer
\lstset{
    tabsize = 2, %% set tab space width
    showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
    basicstyle = \tiny\ttfamily, %% set listing font and size
    breaklines = true, %% enable line breaking
    numberstyle = \tiny,
    postbreak = \mbox{\textcolor{red}{\(\hookrightarrow\)}\space}
}

\begin{center}
    {\textbf{3SH3 Final -- Linus Torvalds Edition}} \\
\end{center}
% set column spacing rules
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}
\begin{multicols*}{6}
    % sections based on slide titles
    \section{Overview}
    \section{Processes}
        \subsection{Process Creation Code}
\begin{lstlisting}[language=C]
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
int main()
{
    pid t pid;
    /* fork a child process */
    pid = fork();
    if (pid < 0) { /* error occurred */
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) { /* child process */
        execlp("/bin/ls","ls",NULL);
    }
    else { /* parent process */
        /* parent will wait for the child to complete */
        wait(NULL);
        printf("Child Complete");
    }
    return 0;
}
\end{lstlisting}
        The \ttt{exit(1)} system call can be used to terminate a process with 
        status 1. The parent can obtain the status of a terminated child with 
        \ttt{pid = wait(\&status)} where \ttt{status} is the integer status of the 
        child process.

        \subsection{Posix Shared Memory}
\begin{lstlisting}[language=C]
/* the size (in bytes) of shared memory object */
const int SIZE = 4096;
/* name of the shared memory object */
const char *name = "OS";
/* shared memory file descriptor */
int fd;
/* pointer to shared memory obect */
char *ptr;

/* create the shared memory object */
fd = shm open(name,O\_CREAT | O\_RDWR,0666);
/* configure the size of the shared memory object */
ftruncate(fd, SIZE);
/* memory map the shared memory object */
ptr = (char *)
mmap(0, SIZE, PROT\_READ | PROT\_WRITE, MAP\_SHARED, fd, 0);

/* write to the shared memory object */
sprintf(ptr,"%s",message\_0);
ptr += strlen(message\_0);
sprintf(ptr,"%s",message\_1);
ptr += strlen(message\_1);
/* read from the shared memory object */
printf("%s",(char *)ptr);

/* remove the shared memory object */
shm\_unlink(name);
\end{lstlisting}        

        \subsection{Pipes}
\begin{lstlisting}[language=C]
#define BUFFER SIZE 25
#define READ END 0
#define WRITE END 1
int main(void)
{
    char write msg[BUFFER\_SIZE] = "Greetings";
    char read msg[BUFFER\_SIZE];
    int fd[2];
    /* create the pipe */
    if (pipe(fd) == -1) {
        fprintf(stderr,"Pipe failed");
        return 1;
    }
    /* fork a child process */
    pid = fork();
    if (pid < 0) { /* error occurred */
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    if (pid > 0) { /* parent process */
        /* close the unused end of the pipe */
        close(fd[READ_END]);
        /* write to the pipe */
        write(fd[WRITE_END], write msg, strlen(write msg)+1);
        /* close the write end of the pipe */
        close(fd[WRITE_END]);
    }
    else { /* child process */
        /* close the unused end of the pipe */
        close(fd[WRITE_END]);
        /* read from the pipe */
        read(fd[READ_END], read msg, BUFFER SIZE);
        printf("read %s",read msg);
        /* close the read end of the pipe */
        close(fd[READ_END]);
    }
    return 0;
}
\end{lstlisting}
    \section{Threads}
        \subsection{Amdahl's Law}
            $speedup \leq \frac{1}{S+(1-S)/N}$ where $S$ is the serial 
            portion of the application and $N$ is the number of processing cores

        Threads of a process share the code section, data section, and files 
        of the process. The registers, stack, and program counter of the threads 
        differ.

        \textbf{Data Parallelism:} distribute subsets of the same data across multiple 
        computing cores. \\
        \textbf{Task Parallelism:} distribute tasks (threads) across multiple 
        computing cores.
    \section{Synchronization}
        \subsection{Semaphores}
            \texttt{wait()} = \texttt{P()}, \texttt{signal()} = \texttt{V()},
            \texttt{wait()} decrements the semaphore, \texttt{signal()} increments the 
            semaphore.
    \section{Deadlocks}
    \section{Scheduling}
        \subsection{Predicting next CPU burst Formula}
            $\tau_{n+1} = \alpha \cdot t_n + (1-\alpha) \cdot \tau_n$
            where $t_n$ is the value of the nth CPU burst, $0 \leq \alpha \leq 1$ \\
            If $\alpha = 0$, then $\tau_{n+1} = \tau_n$ and recent history has 
            no effect on the future CPU burst. If $\alpha = 1$, then 
            $\tau_{n+1} = t_n$ and only the most recent CPU bursts matter (history 
            is assumed to be old and irrelevant). $\alpha = 1/2$ weights recent 
            and past history evenly
        \subsection{Scheduling Algorithms Formulas}
            \textbf{Turnaround time of a process} is difference between when 
            the process finishes execution and its arrival time; 
            turnaround time = process finish time - start time.
            \textbf{Waiting time of a process} is how long a process does not execute 
            on the CPU from its arrival.
            \textbf{CPU utilization rate} is the time the cpu spends executing 
            processes divided by the total time (time spent executing + time spent idle)
    \section{Memory Management}
        \subsection{Paging}
            Given a computer system with a 32-bit logical address and 8-KB page 
            size and supports 1 GB of physical memory, how many entries are in 
            (a) a conventional, single level page table and in (b) an inverted 
            page table? \\
            (a) The logical address space consists of the bits for the page number 
            and the page offset. Each page is 8KB which is $2^{13}$ bytes, so 13 bits 
            are needed for the page offset. As 32-13 = 19, 19 bits are used for 
            the page number and thus the page table can have $2^{19}$ entries. \\
            (b) Inverted page tables keep only one entry for each real page 
            (frame) in memory. 13 bits are still kept for the page offset, but 
            we subtract from  the number of bits used for the physical memory, 
            which is 30 (since $1GB = 2^30$ bytes). 30-13 = 17, thus the 
            number of entries would be $2^{17}$. 
    \section{Virtual Memory}
        \subsection{Demand Paging}
            $\text{\textbf{effective access time}} = (1-p) \cdot ma + p \cdot \text
            {page fault time}$ where $p$ is the probability of a page fault and $ma$
            is the memory access time.
    \section{File System}
        Logic for ``answering maximum size of file'' type questions: multiply the 
        number of direct disk blocks by size of the disk blocks, for indirect 
        disk blocks, divide the size of the disk blocks by the size of a pointer to 
        a disk block, then raise this number by a power which is the same as the
        level of the indirect block (i.e. for single indirect raise by a power of 
        1, for a double indirect raise by a power of 2, and so on). 
        Multiply this value 
        by the size of a disk block and by the amount of that specific indirect 
        disk block, i.e. if you are doing the calculation for 5 single indirect 
        disk blocks, then multiply by 5 at the end. Add the multiplications 
        for all the types of disk blocks together for the final answer.
    \section{Mass Storage Systems}
        \subsection{SCAN Scheduling}
            The disk arm starts at one end of the disk and moves
            toward the other end, servicing requests as it reaches each cylinder,
            until it gets to the other end of the disk. At the other end, the 
            direction of head movement is reversed, and servicing continues
        \subsection{C-SCAN Scheduling}
            C-SCAN moves the head from one end of
            the disk to the other, servicing requests along the way. When the 
            head reaches the other end, however, it immediately returns 
            to the beginning of the disk without servicing any requests on the 
            return trip. Is a variant of SCAN scheduling.
    \section{Conversions}
        1 second = 1000 milliseconds, 1 millisecond = 1000 microseconds, 
        1 microsecond = 1000 nanoseconds.

        $1 KB = 2^{10}$ bytes, $1 MB = 2^{20}$ bytes, $1 GB = 2^{30}$ bytes 
\end{multicols*}

\end{document}
